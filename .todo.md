[] Lightwight documentation.
  Simple and quick.
  Only for possibility to using.
  Because current crazy example so much difficult for any developers.

---
High Priorty!

[] Cancelling all core function calls after unit unlinked
[] I need wrap only JSX return functions ...
    `view_skip_first_deep` has errors if no have JSX inside test body, only inside another funcs

---
[] Make boilerplate project
[] Make first production project

---
[] Make example same that:

```javascript
import React from "react";
import { useQuery } from "react-query";
import axios from "axios";

const fetchTodos = () => {
  const { data } = axios.get("/api/todos");
  return data;
};

const App = () => {
  const { data } = useQuery("todos", fetchTodos);

  return data ? (
    <ul>{data.length > 0 && data.map((todo) => <li>{todo.text}</li>)}</ul>
  ) : null;
};
```
From https://dev.to/g_abud/why-i-quit-redux-1knl

```javascript

const todosUnit = unit({
  todos: [],
  async fetch() {
    const { data } = await axios.get("/api/todos");
    this.todos = data;
  },
  constructor() {
    this.fetch();
  }
});

const App = () => {
  const { todos } = useUnit(todosUnit);

  return (
    <ul>{todos.map((todo) => <li>{todo.text}</li>)}</ul>
  );
};

```

And redux implementation

```javascript
import React, { useEffect } from "react";
import { useSelector, useDispatch } from "react-redux";
import axios from "axios";

const SET_TODOS = "SET_TODOS";

export const rootReducer = (state = { todos: [] }, action) => {
  switch (action.type) {
    case SET_TODOS:
      return { ...state, todos: action.payload };
    default:
      return state;
  }
};

export const App = () => {
  const todos = useSelector((state) => state.todos);
  const dispatch = useDispatch();

  useEffect(() => {
    const fetchPosts = async () => {
      const { data } = await axios.get("/api/todos");
      dispatch({
        type: SET_TODOS,
        payload: data}
      );
    };

    fetchPosts();
  }, []);

  return (
    <ul>{todos.map((todo) => <li>{todo.text}</li>)}</ul>
  );
};
```

---
[] Think about possibility to listen redux actions. Research it.

---
[] Make unit function `unit.combine`

```javascript
let u1 = unit({
  a: 11,
  b() {}
});

let u2 = unit({
  a: 12,
  m() {}
});

let u_ = unit.combine(u1, u2); // { a: 12, b() {}, m() {} }
```

[] For accessing to parent method in override func
  your can use `super` keyword for call overrided function. (Optional)

```javascript
let u2 = unit({
  b() {
    super();
  }
});

let u_ = unit.combine(u1, u2);
```



---
[] bubble

[] Effector style usage example
[] Recoil style usage example
[] React+redux view performance test

[] Modern async operations

[] Fix both box bugs
  (One from old perf test, second from todo comment in core box code)

[] View performance test
    [] mobx-react

[] Add React components view performance optimization
  (optimization after test stand)
