
[] Simple wasm compiler
  [] Replace builder wat to js in project from external library.
  Add preprocessor directives to wat files.

(;;if DEBUG;;)

(;;/if;;)

(;;import set.wat;;)

And separate all wat code to different files for better
reading, understanging, refactoring and simplify

And add simple logic and mathematic constructions

(;;call $set_offset_i $offset + 1, $i + $k - 1, $n ;;)
(;;$offset + 10)
(;;$offset = 10 + $i + 15)
(;;$index != $size - 1)

And store directive

(;;store $offset)
(;;store $offset = 10)

--
Optional:
[] And I think to add simple pointer (think about It, may be It not need now)

(;;ptr $ptr)
(;;ptr $ptr = 10)

We need add to top of memory 64k for pointers
Pointers placed from 1 to 65535 bytes
Zero byte is reserved

All other memory separated by pages by 64bytes
All address memory on first pointer page
  65536 + 65535 * 64 = 4259776 bytes
We can calculate which pointer map we need by
  next operation
  ;; 2,4,8,16,32,64,128,256(8),512,1024(10),2048,4096,8,16,32,64
  ptr << 20 -> 0, or 1, or 2, etc.

Zero pointer is free.
We need struct for storing pointers...

---

[] Rewrite unit builder, merge wasm branch to master

## Unit constructor build

```javascript
const u = unit({
  first_name: '',
  last_name: '',
  get name() {
    return this.first_name + ' ' = this.last_name;
  },
  set name(full_name) {
    [this.first_name, this.last_name] = full_name.split(' ');
  },
  construct() {},
  async sync() {
    await fetch('/');
  }
});
```

Should be compile to that

```javascript
const u = unit([function f() {
  let
    _u_box_id = box(),
    _first_name = '',
    _first_name_box_id = box(),
    _last_name = '',
    _name_computed_box_id = box();

  // Think about this. May be we need extend self obj

  return {
    [meta_unit]: [/* */],
    get first_name() {
      int_box_read(_first_name_box_id);
      return _first_name;
    },
    set first_name(v) {
      if (!Object.is(_first_name, v)) {
        _first_name = v
        int_box_change(_first_name_box_id);
      }
    },
    // ...
    get name() {
      int_computed_start(_name_computed_box_id);
      return [ // Each return section will be extended
        (this.first_name + ' ' = this.last_name),
        int_computed_finish(_name_computed_box_id)
      ][0];
    },
    set name(full_name) {
      const _no_tick = int_no_tick;
      if (_no_tick) int_tick_start();
      [this.first_name, this.last_name] = full_name.split(' ');
      if (_no_tick) int_tick_finish();
    },
    sync: async () => { // Bind this automatically
      /* */ int_store_context(_u_box_id);
      await fetch('/');
      /* */ int_load_context(_u_box_id); // After await
    }
  }
}, f[meta_unit_factory] = [/* */]][0]); // Add meta to unit f
```

Or

```javascript
const u = unit(function f(self) {
  // **

  Object.defineProperties(self, {
    first_name: {
      set: () => {} // Autobinding this
      get: () => {} // Autobinding this
    },
    // **
  });

  // **
  return self;
});

```

View build, decrease callback nesting for performace reason I think

```javascript
function App() {
  return <JSX />
}
```

Compile to

```javascript
function App() {
  view_start(); // Possible to only start, but better finish it here
  return [<JSX />, view_finish()][0]
}
```

---

[] bubble
[] Lightwight documentation. Simple and quick. Only for possibility to using. Because current crazy example so much difficult for any developers.

---

[] Make the Redux style example (for example look likes that below):
(Or try to make for Redux style example, search Redux docs)

```javascript

const store = unit({
  state: [
    { title: 'Todo 1' },
    { title: 'Todo 2', completed: true }
  ],
  get completed() {
    return this.state.filter(i => i.completed);
  },
  add(title, completed = false) {
    this.state = [ ...this.state, { title, completed }];
  },
  toggle(i) {
    const { state } = this;
    const index = state.indexOf(i);
    this.state = [
      ...state.slice(0, index),
      { ...i, completed: !i.completed },
      ...state.slice(index+1)
    ];
  }
})

```
