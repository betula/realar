
[] Rewrite box to new compiler
[] Change unit babel compile process

New expression function will be look like same that:

expression() {}

to

/* EXPRESSION_PROP */, id = box_expr_create(), expr_fn = () => {
  box_expr_start(id);
  /* body func */
  this.u = 10;
  /* body end */
  box_expr_finish(id);
}, core.fns.set(box_expr_make(id), expr_fn),

/* box_expr_fn(id, expr_fn) */

---

/* CONSTRUCTOR_PROP */, () => {
  box_entry_start();
  /* body func */
  box_entry_finish();
}

---

/* DESTRUCTOR_PROP */, () => {
  /* body func */
}

---

/* COMPUTED_PROP */, "name", id = box_computed_create(), () => {
  box_computed_start(id)
  /* body func */
  box_computed_finish(id)
}

---

/* VALUE_PROP */, "name", value = initialValue, id = box_value_create(), () => {
  box_value_get_phase(id)
  return value;
}, (val) => {
  if (Object.is(value, val)) return;
  if (value && value[unit_inst_key]) unlink(value);
  value = val;
  if (value && value[unit_inst_key]) link(value);
  box_value_set_phase(id)
}

I can make unit2 function call, for new parser mode.

Renaming:
synchronize -> expression
construct -> constructor
destruct -> destructor
---

And I need add quick way for schema mock building

unit2(function(/* arguments */) {

}, ["val1", "val2"], ["comp1", "comp2"], ["method1", "method2"])

----------

  const expected = `const Unit = unit2(function () {
    let v_1 = 1; /* v: 1 */
    let v_1_id = box_value_create();
    let v_1_linked = 0
    return [
      () => {
        box_value_get_phase(id)
        return v_1;
      },
      (v) => {
        if (Object.is(v_1, v)) return;
        if (v_1_linked) v_1_linked = unlink(v_1), 0;
        v_1 = v;
        if (v && v[unit_inst_key]) v_1_linked = link(v), 1;
        box_value_set_phase(id);
      }
    ]
}, ["v"]);`;

-----------


---

[] Rewrite unit builder

## Unit constructor build

```javascript
const u = unit({
  first_name: '',
  last_name: '',
  get name() {
    return this.first_name + ' ' = this.last_name;
  },
  set name(full_name) {
    [this.first_name, this.last_name] = full_name.split(' ');
  },
  construct() {},
  async sync() {
    await fetch('/');
  }
});
```

Should be compile to that

```javascript
const u = unit([function f() {
  let
    _u_box_id = box(),
    _first_name = '',
    _first_name_box_id = box(),
    _last_name = '',
    _name_computed_box_id = box();

  // Think about this. May be we need extend self obj

  return {
    [meta_unit]: [/* */],
    get first_name() {
      int_box_read(_first_name_box_id);
      return _first_name;
    },
    set first_name(v) {
      if (!Object.is(_first_name, v)) {
        _first_name = v
        int_box_change(_first_name_box_id);
      }
    },
    // ...
    get name() {
      int_computed_start(_name_computed_box_id);
      return [ // Each return section will be extended
        (this.first_name + ' ' = this.last_name),
        int_computed_finish(_name_computed_box_id)
      ][0];
    },
    set name(full_name) {
      const _no_tick = int_no_tick;
      if (_no_tick) int_tick_start();
      [this.first_name, this.last_name] = full_name.split(' ');
      if (_no_tick) int_tick_finish();
    },
    sync: async () => { // Bind this automatically
      /* */ int_store_context(_u_box_id);
      await fetch('/');
      /* */ int_load_context(_u_box_id); // After await
    }
  }
}, f[meta_unit_factory] = [/* */]][0]); // Add meta to unit f
```

Or

```javascript
const u = unit(function f(self) {
  // **

  Object.defineProperties(self, {
    first_name: {
      set: () => {} // Autobinding this
      get: () => {} // Autobinding this
    },
    // **
  });

  // **
  return self;
});

```

View build, decrease callback nesting for performace reason I think

```javascript
function App() {
  return <JSX />
}
```

Compile to

```javascript
function App() {
  view_start(); // Possible to only start, but better finish it here
  return [<JSX />, view_finish()][0]
}
```

---

[] bubble
[] Lightwight documentation. Simple and quick. Only for possibility to using. Because current crazy example so much difficult for any developers.

[] Effector style usage example
[] Recoil style usage example

[] vscode extension for u32
  https://code.visualstudio.com/api/language-extensions/syntax-highlight-guide
